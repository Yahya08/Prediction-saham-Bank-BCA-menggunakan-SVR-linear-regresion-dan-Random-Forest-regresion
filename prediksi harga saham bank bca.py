# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RGrHIxGLNU9jvOgWjc6hu9nMpTVQ8jK_

Nama: Yahya Handarestanto

Nim : 21.11.4365

kelas: 21.if08

## Akusisi Data

A.	Latar Belakang
Prediksi harga saham memiliki nilai penting bagi investor dan pelaku pasar untuk mengantisipasi arah pergerakan harga di masa mendatang. Dengan memahami tren dan pola yang mendasari pergerakan harga, investor dapat membuat keputusan yang lebih tepat dalam membeli, menjual, atau mempertahankan saham mereka.

B. Metode yang digunakan
•	Linear Regresion Dan Random Forest Regresion
Linear Regression dapat digunakan untuk menangani hubungan linier yang sederhana antara variabel independen dan dependen. Ini berguna jika terdapat faktor-faktor yang memiliki hubungan linier dengan harga saham. Sementara itu, Random Forest Regression dapat menangani pola yang lebih kompleks dan non-linear dalam data, yang mungkin terjadi dalam situasi di mana hubungan antara variabel independen dan dependen tidak linier.

C.	Cara kerja solusi
•	Pemodelan linear Regression dan Random forest regresion
•	Prediksi: Lakukan prediksi harga saham menggunakan model regresion.
•	Evaluasi dan Penyetelan
•	Pemisahan Data
•	Pengujian dan Validasi

D.	Dataseet
https://www.kaggle.com/datasets/caesarmario/bank-central-asia-stock-historical-price?select=BBCA.JK_monthly.csv

# Import Library
"""

!pip install scikit-learn
!pip install matplotlib-venn
!pip install scipy

# Commented out IPython magic to ensure Python compatibility.
# library untuk plot grafik
import matplotlib.pyplot as plt
from matplotlib import style
import datetime # library untuk mengelola tanggal dan waktu

import pandas as pd ###manipulasi dan analisis data tabular
import numpy as np ###pengolahan data numerik
import matplotlib.pyplot as plt ###membuat visualisasi, grafik, dan plot data.
import seaborn as sns ### membuat visualisasi data yang lebih menarik dan informatif dengan lebih sedikit kode

sns.set_style("whitegrid") ###latar belakang plot akan menjadi putih, dan grid akan ditampilkan di belakang plot
plt.style.use("fivethirtyeight") ###visualisasi data yang mirip dengan yang digunakan oleh FiveThirtyEight

###plot Matplotlib ditampilkan dalam notebook secara langsung
# %matplotlib inline
from datetime import datetime ###impor fungsi datetime

from sklearn.preprocessing import MinMaxScaler ###import untuk normalisasi data
import pandas as pd

"""# Menampilkan dataseet"""

from google.colab import drive
drive.mount('/content/drive')

BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')
# Tampil BANK BCA
BBCA.head(10)

# Tampil bank bca
print(BBCA)

# Tipe Data
BBCA.dtypes

BBCA.describe()

"""## Exploratory Data Analysis"""

print("Informasi Variabel Saham Bank BCA \n")
# df.info digunakan untuk menampilkan informasi detail tentang dataframe
# seperti jumlah baris data, nama kolom beserta jumlah data dan tipe datanya.
BBCA.info()

#check duplication
BBCA.nunique()

BBCA.isnull().sum()

"""# Kurva Skewness"""

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.dates import DateFormatter

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')
BBCA['Date'] = pd.to_datetime(BBCA['Date'])  # Mengubah kolom 'Date' menjadi tipe datetime

# Menampilkan kurva dari kolom 'Close'
plt.figure(figsize=(10, 6))
plt.plot(BBCA['Date'], BBCA['Close'], color='blue', marker='o', linestyle='-')
plt.title('Bank BCA Closing Price')
plt.xlabel('Date')
plt.ylabel('Closing Price (IDR)')
plt.gca().xaxis.set_major_formatter(DateFormatter('%Y'))  # Format label sumbu x sesuai tahun
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

# Library Kurva Skewness
import scipy
from scipy.stats import skew

# Library Visualisasi
import matplotlib.pyplot as plt
import seaborn as sns

# Kurva Skewness Saham Telkomsel
data_bca = BBCA.iloc[:,1:].fillna(-9999)
print("skewness = ", scipy.stats.skew(data_bca))

import pandas as pd
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Membuat box plot dari kolom 'Close'
plt.figure(figsize=(8, 6))
plt.boxplot(BBCA['Close'])
plt.title('Box Plot of Bank BCA Closing Price')
plt.ylabel('Closing Price (IDR)')
plt.grid(True)
plt.show()

"""#Outlier"""

# Library Outlier
import seaborn as sns

import pandas as pd
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menampilkan box plot untuk setiap fitur
plt.figure(figsize=(12, 8))
for i, column in enumerate(BBCA.columns[1:]):  # Exclude 'Date' column
    plt.subplot(3, 2, i+1)
    plt.boxplot(BBCA[column])
    plt.title(f'Box Plot of {column}')
    plt.ylabel(column)
plt.tight_layout()
plt.show()

"""# Open"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Open'].quantile(0.25)
Q3 = BBCA['Open'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengecek apakah ada outlier
outliers = BBCA[(BBCA['Open'] < lower_bound) | (BBCA['Open'] > upper_bound)]

if outliers.empty:
    print("Tidak ada outlier pada kolom 'Open'.")
else:
    print("Ada outlier pada kolom 'Open':")
    print(outliers)

"""# HIGH"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['High'].quantile(0.25)
Q3 = BBCA['High'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengecek apakah ada outlier
outliers = BBCA[(BBCA['High'] < lower_bound) | (BBCA['High'] > upper_bound)]

if outliers.empty:
    print("Tidak ada outlier pada kolom 'High'.")
else:
    print("Ada outlier pada kolom 'High':")
    print(outliers)

"""# low"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Low'].quantile(0.25)
Q3 = BBCA['Low'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengecek apakah ada outlier
outliers = BBCA[(BBCA['Low'] < lower_bound) | (BBCA['Low'] > upper_bound)]

if outliers.empty:
    print("Tidak ada outlier pada kolom 'Low'.")
else:
    print("Ada outlier pada kolom 'Low':")
    print(outliers)

"""#close"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Close'].quantile(0.25)
Q3 = BBCA['Close'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengecek apakah ada outlier
outliers = BBCA[(BBCA['Close'] < lower_bound) | (BBCA['Close'] > upper_bound)]

if outliers.empty:
    print("Tidak ada outlier pada kolom 'Close'.")
else:
    print("Ada outlier pada kolom 'Close':")
    print(outliers)

"""###Adj Close"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Adj Close'].quantile(0.25)
Q3 = BBCA['Adj Close'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengecek apakah ada outlier
outliers = BBCA[(BBCA['Adj Close'] < lower_bound) | (BBCA['Adj Close'] > upper_bound)]

if outliers.empty:
    print("Tidak ada outlier pada kolom 'Adj Close'.")
else:
    print("Ada outlier pada kolom 'Adj Close':")
    print(outliers)

"""###Volume"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Volume'].quantile(0.25)
Q3 = BBCA['Volume'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengecek apakah ada outlier
outliers = BBCA[(BBCA['Volume'] < lower_bound) | (BBCA['Volume'] > upper_bound)]

if outliers.empty:
    print("Tidak ada outlier pada kolom 'Volume'.")
else:
    print("Ada outlier pada kolom 'Volume':")
    print(outliers)

"""# Preprocessing"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Volume'].quantile(0.25)
Q3 = BBCA['Volume'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengganti nilai outlier dengan nilai median
median_volume = BBCA['Volume'].median()
BBCA['Volume'] = BBCA['Volume'].apply(lambda x: median_volume if x < lower_bound or x > upper_bound else x)

# Menampilkan informasi dataset setelah handling outlier
print("Informasi dataset setelah handling outlier:")
print(BBCA.info())

# Menampilkan statistik deskriptif dataset setelah handling outlier
print("\nStatistik deskriptif dataset setelah handling outlier:")
print(BBCA.describe())

import pandas as pd
from sklearn.preprocessing import StandardScaler

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Volume'].quantile(0.25)
Q3 = BBCA['Volume'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Menghapus outlier dari dataset
BBCA_no_outliers = BBCA[(BBCA['Volume'] >= lower_bound) & (BBCA['Volume'] <= upper_bound)]

# Melakukan normalisasi menggunakan StandardScaler
scaler = StandardScaler()
BBCA_no_outliers['Volume_Normalized'] = scaler.fit_transform(BBCA_no_outliers[['Volume']])

# Menampilkan 10 baris pertama dataset setelah normalisasi
print("10 baris pertama dataset setelah normalisasi:")
print(BBCA_no_outliers.head(10))

import pandas as pd
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3)
Q1 = BBCA['Volume'].quantile(0.25)
Q3 = BBCA['Volume'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengekstrak outlier
outliers = BBCA[(BBCA['Volume'] < lower_bound) | (BBCA['Volume'] > upper_bound)]

# Menampilkan outlier
plt.figure(figsize=(10, 6))
plt.scatter(BBCA.index, BBCA['Volume'], color='blue', label='Data')
plt.scatter(outliers.index, outliers['Volume'], color='red', label='Outlier')
plt.title('Outlier Detection on Volume Column')
plt.xlabel('Index')
plt.ylabel('Volume')
plt.legend()
plt.show()

"""##Data Cleaning

data cleaning bermaksud membersihkan data sederhana. dengan membersihkan data yang kosong atau data yang bukan suatu angka (not a number), maka dilakukan pergantian dengan angka -99999 agar dibaca menjadi nilai ekstrem dan dapat diabaikan.
"""

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menampilkan informasi tentang dataset sebelum proses data cleaning
print("Informasi dataset sebelum proses data cleaning:")
print(BBCA.info())

# Menghapus baris yang memiliki nilai kosong (null)
BBCA_cleaned = BBCA.dropna()

# Menghapus baris yang memiliki nilai yang bukan suatu angka pada kolom 'Volume'
BBCA_cleaned = BBCA_cleaned[pd.to_numeric(BBCA_cleaned['Volume'], errors='coerce').notnull()]

# Mengubah tipe data kolom 'Volume' menjadi float
BBCA_cleaned['Volume'] = BBCA_cleaned['Volume'].astype(float)

# Menampilkan informasi tentang dataset setelah proses data cleaning
print("\nInformasi dataset setelah proses data cleaning:")
print(BBCA_cleaned.info())

# Menyimpan dataset yang telah dibersihkan ke file CSV baru
BBCA_cleaned.to_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA_cleaned.csv', index=False)

# Menampilkan 10 baris pertama dataset yang telah dibersihkan
print("\n10 baris pertama dataset yang telah dibersihkan:")
print(BBCA_cleaned.head(10))

"""# BUAT DATAFRAME"""

data_BBCA_X = np.array(data_baru[['Close', 'Volume', '%Change', 'Spread']])
data_BBCA_X

"""# NORMALISASI"""

from sklearn import preprocessing

#Normalisasi dengan mengubah nilai menjadi rentan -1 hingga 1
data_BBCA_X = preprocessing.scale(data_BBCA_X)

data_BBCA_X_prediksi = data_BBCA_X[-jml_sampel_prekdiksi:]
data_BBCA_X = data_BBCA_X[:-jml_sampel_prekdiksi] #data 99% elemen
data_BBCA_X

data_baru.dropna(inplace=True) #menghapus nilai yang 'not a number'/NaN
data_BBCA_Y = np.array(data_baru['Output Prediksi']) # varibel ini berisi nilai Output Prediksi
data_BBCA_Y

import pandas as pd

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Menghitung quartile 1 (Q1) dan quartile 3 (Q3) dari kolom 'Volume'
Q1 = BBCA['Volume'].quantile(0.25)
Q3 = BBCA['Volume'].quantile(0.75)

# Menghitung rentang interquartile (IQR)
IQR = Q3 - Q1

# Menentukan batas bawah dan batas atas untuk outlier pada kolom 'Volume'
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Menghapus baris yang memiliki nilai outlier pada kolom 'Volume'
BBCA_no_outliers = BBCA[(BBCA['Volume'] >= lower_bound) & (BBCA['Volume'] <= upper_bound)]

# Menampilkan informasi dataset setelah preprocessing
print("Informasi dataset setelah preprocessing:")
print(BBCA_no_outliers.info())

# Menyimpan dataset yang telah dipreprocessing ke file CSV baru
BBCA_no_outliers.to_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA_no_outliers.csv', index=False)

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

# Bagi data menjadi data latih dan data uji
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalisasi fitur
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Bangun model regresi linear
model = LinearRegression()
model.fit(X_train_scaled, y_train)

# Lakukan prediksi pada data uji
y_pred = model.predict(X_test_scaled)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji:", mse)

# Visualisasi hasil prediksi
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.xlabel("Harga Asli")
plt.ylabel("Prediksi Harga")
plt.title("Prediksi Harga vs Harga Asli")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Proses data untuk menghapus outlier pada kolom 'Volume'
Q1 = BBCA['Volume'].quantile(0.25)
Q3 = BBCA['Volume'].quantile(0.75)
IQR = Q3 - Q1
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR
BBCA_cleaned = BBCA[(BBCA['Volume'] >= lower_bound) & (BBCA['Volume'] <= upper_bound)]

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

# Bagi data menjadi data latih dan data uji
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalisasi fitur
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Bangun model regresi linear
model = LinearRegression()
model.fit(X_train_scaled, y_train)

# Lakukan prediksi pada data uji
y_pred = model.predict(X_test_scaled)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji:", mse)

# Visualisasi hasil prediksi
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.xlabel("Harga Asli")
plt.ylabel("Prediksi Harga")
plt.title("Prediksi Harga vs Harga Asli")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import Ridge
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Proses data untuk menghapus outlier pada kolom 'Volume' secara lebih ketat
Q1 = BBCA['Volume'].quantile(0.01)  # Menggunakan quantile 1% sebagai batas bawah
Q3 = BBCA['Volume'].quantile(0.99)  # Menggunakan quantile 99% sebagai batas atas
BBCA_cleaned = BBCA[(BBCA['Volume'] >= Q1) & (BBCA['Volume'] <= Q3)]

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

# Bagi data menjadi data latih dan data uji
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalisasi fitur dengan StandardScaler
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Bangun model regresi linear dengan regularisasi L2 (Ridge Regression)
alpha = 0.1  # Parameter alpha untuk regularisasi
model = Ridge(alpha=alpha)
model.fit(X_train_scaled, y_train)

# Lakukan prediksi pada data uji
y_pred = model.predict(X_test_scaled)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji:", mse)

# Visualisasi hasil prediksi
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.xlabel("Harga Asli")
plt.ylabel("Prediksi Harga")
plt.title("Prediksi Harga vs Harga Asli")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Proses data untuk menghapus outlier pada kolom 'Volume' secara lebih ketat
Q1 = BBCA['Volume'].quantile(0.01)  # Menggunakan quantile 1% sebagai batas bawah
Q3 = BBCA['Volume'].quantile(0.99)  # Menggunakan quantile 99% sebagai batas atas
BBCA_cleaned = BBCA[(BBCA['Volume'] >= Q1) & (BBCA['Volume'] <= Q3)]

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

# Bagi data menjadi data latih dan data uji
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Bangun model Random Forest Regression
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Lakukan prediksi pada data uji
y_pred = model.predict(X_test)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji:", mse)

# Visualisasi hasil prediksi
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.xlabel("Harga Asli")
plt.ylabel("Prediksi Harga")
plt.title("Prediksi Harga vs Harga Asli")
plt.show()

from sklearn.model_selection import GridSearchCV

# Menentukan rentang parameter yang akan diuji
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}

# Inisialisasi model RandomForestRegressor
rf = RandomForestRegressor(random_state=42)

# Membuat objek GridSearchCV
grid_search = GridSearchCV(estimator=rf, param_grid=param_grid, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)

# Melakukan pencarian parameter terbaik
grid_search.fit(X_train, y_train)

# Menampilkan parameter terbaik
print("Parameter terbaik:", grid_search.best_params_)

# Menggunakan model dengan parameter terbaik
best_model = grid_search.best_estimator_

# Lakukan prediksi pada data uji
y_pred = best_model.predict(X_test)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji setelah penyetelan parameter:", mse)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Proses data untuk menghapus outlier pada kolom 'Volume'
Q1 = BBCA['Volume'].quantile(0.01)  # Menggunakan quantile 1% sebagai batas bawah
Q3 = BBCA['Volume'].quantile(0.99)  # Menggunakan quantile 99% sebagai batas atas
BBCA_cleaned = BBCA[(BBCA['Volume'] >= Q1) & (BBCA['Volume'] <= Q3)].copy()

# Feature engineering: Menambahkan fitur baru, misalnya rata-rata perubahan harga
BBCA_cleaned.loc[:, 'AvgPriceChange'] = (BBCA_cleaned['High'] - BBCA_cleaned['Low']) / BBCA_cleaned['Low']

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume', 'AvgPriceChange']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

# Normalisasi fitur dengan StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Bagi data menjadi data latih dan data uji
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Bangun model Random Forest Regression
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Lakukan prediksi pada data uji
y_pred = model.predict(X_test)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji:", mse)

# Hitung nilai RMSE
rmse = mse ** 0.5
print("Root Mean Squared Error (RMSE) pada data uji:", rmse)

# Visualisasi hasil prediksi
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.xlabel("Harga Asli")
plt.ylabel("Prediksi Harga")
plt.title("Prediksi Harga vs Harga Asli")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Membaca dataset
BBCA = pd.read_csv('/content/drive/MyDrive/PROYEK DATAMINING/BBCA.JK.csv')

# Proses data untuk menghapus outlier pada kolom 'Volume'
Q1 = BBCA['Volume'].quantile(0.01)  # Menggunakan quantile 1% sebagai batas bawah
Q3 = BBCA['Volume'].quantile(0.99)  # Menggunakan quantile 99% sebagai batas atas
BBCA_cleaned = BBCA[(BBCA['Volume'] >= Q1) & (BBCA['Volume'] <= Q3)]

# Preprocessing data
X = BBCA_cleaned[['Open', 'High', 'Low', 'Volume']]  # Fitur yang akan digunakan
y = BBCA_cleaned['Close']  # Target

# Normalisasi fitur dengan StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Bagi data menjadi data latih dan data uji
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Bangun model Random Forest Regression
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10],
    'min_samples_leaf': [1, 2, 4]
}
model = RandomForestRegressor(random_state=42)
grid_search = GridSearchCV(estimator=model, param_grid=param_grid, cv=5, scoring='neg_mean_squared_error')
grid_search.fit(X_train, y_train)

# Mendapatkan model terbaik dari hasil grid search
best_model = grid_search.best_estimator_

# Lakukan prediksi pada data uji menggunakan model terbaik
y_pred = best_model.predict(X_test)

# Evaluasi model menggunakan mean squared error (MSE)
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error (MSE) pada data uji:", mse)

# Hitung nilai RMSE
rmse = mse ** 0.5
print("Root Mean Squared Error (RMSE) pada data uji:", rmse)

# Visualisasi hasil prediksi
plt.figure(figsize=(8, 6))
plt.scatter(y_test, y_pred)
plt.xlabel("Harga Asli")
plt.ylabel("Prediksi Harga")
plt.title("Prediksi Harga vs Harga Asli")
plt.show()

"""##Menentukan Data Training dan Testing"""

! pip install scikit-learn

#Mencari ukuran data_telkom_X
data_BBCA_X.shape[0]

#Mencari ukuran data_telkom_Y
data_BBCA_Y.shape[0]

from sklearn.model_selection import train_test_split

# Membagi data training 80% dan data testing 20%
X_train, X_test, y_train, y_test = train_test_split(data_BBCA_X, data_BBCA_X, random_state = 100, test_size=0.2)

"""##Training Data"""

from sklearn.linear_model import LinearRegression

# regresi linier sebagai classifier dengan proses training
linreg = LinearRegression(n_jobs=-1)
linreg.fit(X_train, y_train) # lakukan training

set_prediksi = linreg.predict(data_BBCA_X_prediksi) # prediksi nilai y (output)
set_prediksi

"""#Mencari Nilai Confident (Akurasi)"""

confidence = linreg.score(X_test, y_test) # hitung score
print(confidence) # Nilai akurasi model

"""# GRAFIK"""

data_BBCA

# Membuat dataframe baru yang berisi nilai prediksi harga saham
data_baru = data_BBCA[['Date', 'Close', 'Spread', '%Change', 'Volume']]
data_baru['Prediksi'] = np.nan
data_baru